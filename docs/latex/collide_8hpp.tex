\doxysection{src/collide.hpp File Reference}
\hypertarget{collide_8hpp}{}\label{collide_8hpp}\index{src/collide.hpp@{src/collide.hpp}}


Contains different types of collision detection and resolve functions.  


{\ttfamily \#include "{}tile\+Map.\+hpp"{}}\newline
\doxysubsubsection*{Classes}
\begin{DoxyCompactItemize}
\item 
class \mbox{\hyperlink{struct_collision_manifold}{Collision\+Manifold}}
\begin{DoxyCompactList}\small\item\em Defines the relevant collision information generated by detect\+Narrow\+Colllision() to both resolve the collision through its normals and impulse. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structdebug_1_1_collide_info}{debug\+::\+Collide\+Info}}
\item 
class \mbox{\hyperlink{struct_tile_body_collision_cache}{Tile\+Body\+Collision\+Cache$<$ Tile\+Data $>$}}
\begin{DoxyCompactList}\small\item\em Used to speed up the collision detection between two tile bodies. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{struct_impulse_method}{Impulse\+Method}}
\begin{DoxyCompactList}\small\item\em Resolves the collision between two bodies using the impulse method. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{struct_impulse_method_1_1_impulse}{Impulse\+Method\+::\+Impulse}}
\end{DoxyCompactItemize}
\doxysubsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
{\footnotesize template$<$class Box\+Vertex\+Container , class Normal\+Container $>$ }\\bool \mbox{\hyperlink{collide_8hpp_a6ac4ea60615ca0897b0d8865b4f2c24e}{sat\+Box\+Test}} (const Box\+Vertex\+Container \&vertices1, const Box\+Vertex\+Container \&vertices2, const Normal\+Container \&normals, \mbox{\hyperlink{struct_collision_manifold}{Collision\+Manifold}} \&manifold)
\begin{DoxyCompactList}\small\item\em Returns the normal and depth of two polygons defined by the vertices {\ttfamily vertices1} and {\ttfamily vertices2} by using {\ttfamily normals} inside of the {\ttfamily manifold}. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Container , typename Integer $>$ }\\void \mbox{\hyperlink{collide_8hpp_a8b4c1b30fc6db9efd6a7d53fc7a5d764}{find\+Closest\+Point}} (vec2 \&cp1, vec2 \&cp2, Integer \&count, Float \&distance1, const Container \&points1, const Container \&points2)
\begin{DoxyCompactList}\small\item\em Finds the closest point between points1 and the faces defined by points2. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Container $>$ }\\void \mbox{\hyperlink{collide_8hpp_ada21f910c472533408e13358ccfd4a9d}{compute\+Box\+Manifold}} (const Container \&points1, const Container \&points2, \mbox{\hyperlink{struct_collision_manifold}{Collision\+Manifold}} \&manifold)
\begin{DoxyCompactList}\small\item\em Finds the closest point between points1 and the faces defined by points2. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Tile\+Data $>$ }\\bool \mbox{\hyperlink{collide_8hpp_a6eb18fd72fcf6d0ab2bdad4e42bdf81a}{detect\+Narrow\+Collision}} (const \mbox{\hyperlink{class_tile_body}{Tile\+Body}}$<$ Tile\+Data $>$ \&body1, const glm\+::i32vec2 \&tile\+Pos1, const vec2 \&body1\+Offset, const \mbox{\hyperlink{class_tile_body}{Tile\+Body}}$<$ Tile\+Data $>$ \&body2, const glm\+::i32vec2 \&tile\+Pos2, const vec2 \&body2\+Offset, \mbox{\hyperlink{struct_collision_manifold}{Collision\+Manifold}} \&manifold)
\begin{DoxyCompactList}\small\item\em Detects the collision between the tile in {\ttfamily tile\+Pos1} of {\ttfamily body1} and the tile {\ttfamily tile\+Pos2} of body2. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Tile\+Data $>$ }\\void \mbox{\hyperlink{collide_8hpp_ae2b3dc6f9424aaa03ffca4c47c066863}{detect\+Tile\+Body\+Collision}} (const \mbox{\hyperlink{class_tile_body}{Tile\+Body}}$<$ Tile\+Data $>$ \&body1, const \mbox{\hyperlink{class_tile_body}{Tile\+Body}}$<$ Tile\+Data $>$ \&body2, \mbox{\hyperlink{struct_tile_body_collision_cache}{Tile\+Body\+Collision\+Cache}}$<$ Tile\+Data $>$ \&cache, std\+::vector$<$ \mbox{\hyperlink{struct_collision_manifold}{Collision\+Manifold}} $>$ \&manifolds, vec2 \&body1\+Offset, vec2 \&body2\+Offset)
\begin{DoxyCompactList}\small\item\em Detects the collision between the tiles bodies, body1 and body2. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsubsection*{Variables}
\begin{DoxyCompactItemize}
\item 
std\+::vector$<$ \mbox{\hyperlink{structdebug_1_1_collide_info}{Collide\+Info}} $>$ \mbox{\hyperlink{collide_8hpp_ad9dbe769c3903fe9993db6014bfbfdb4}{debug\+::collide\+Infos}}
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
Contains different types of collision detection and resolve functions. 



Definition in file \mbox{\hyperlink{collide_8hpp_source}{collide.\+hpp}}.



\doxysubsection{Function Documentation}
\Hypertarget{collide_8hpp_ada21f910c472533408e13358ccfd4a9d}\label{collide_8hpp_ada21f910c472533408e13358ccfd4a9d} 
\index{collide.hpp@{collide.hpp}!computeBoxManifold@{computeBoxManifold}}
\index{computeBoxManifold@{computeBoxManifold}!collide.hpp@{collide.hpp}}
\doxysubsubsection{\texorpdfstring{computeBoxManifold()}{computeBoxManifold()}}
{\footnotesize\ttfamily template$<$typename Container $>$ \\
void compute\+Box\+Manifold (\begin{DoxyParamCaption}\item[{const Container \&}]{points1,  }\item[{const Container \&}]{points2,  }\item[{\mbox{\hyperlink{struct_collision_manifold}{Collision\+Manifold}} \&}]{manifold }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Finds the closest point between points1 and the faces defined by points2. 

The size of vertices1 and vertices2 must be 4. The size of normals must be 2.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em points1} & The set of points used to find the closest point in the faces defined by points2 \\
\hline
\mbox{\texttt{ in}}  & {\em points2} & The set of points that define faces that points1 will check against \\
\hline
\mbox{\texttt{ in,out}}  & {\em manifold} & The normal and depth must be already calculated within manifold. The contact points betweeen the shapes defined by points1 and points2 will be written inside of manifold \\
\hline
\end{DoxyParams}


Definition at line \mbox{\hyperlink{collide_8hpp_source_l00177}{177}} of file \mbox{\hyperlink{collide_8hpp_source}{collide.\+hpp}}.

\Hypertarget{collide_8hpp_a6eb18fd72fcf6d0ab2bdad4e42bdf81a}\label{collide_8hpp_a6eb18fd72fcf6d0ab2bdad4e42bdf81a} 
\index{collide.hpp@{collide.hpp}!detectNarrowCollision@{detectNarrowCollision}}
\index{detectNarrowCollision@{detectNarrowCollision}!collide.hpp@{collide.hpp}}
\doxysubsubsection{\texorpdfstring{detectNarrowCollision()}{detectNarrowCollision()}}
{\footnotesize\ttfamily template$<$class Tile\+Data $>$ \\
bool detect\+Narrow\+Collision (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{class_tile_body}{Tile\+Body}}$<$ Tile\+Data $>$ \&}]{body1,  }\item[{const glm\+::i32vec2 \&}]{tile\+Pos1,  }\item[{const vec2 \&}]{body1\+Offset,  }\item[{const \mbox{\hyperlink{class_tile_body}{Tile\+Body}}$<$ Tile\+Data $>$ \&}]{body2,  }\item[{const glm\+::i32vec2 \&}]{tile\+Pos2,  }\item[{const vec2 \&}]{body2\+Offset,  }\item[{\mbox{\hyperlink{struct_collision_manifold}{Collision\+Manifold}} \&}]{manifold }\end{DoxyParamCaption})}



Detects the collision between the tile in {\ttfamily tile\+Pos1} of {\ttfamily body1} and the tile {\ttfamily tile\+Pos2} of body2. 

In order to not modify body1 and body2, \doxylink{collide_8hpp_ae2b3dc6f9424aaa03ffca4c47c066863}{detect\+Tile\+Body\+Collision()} uses offsets that are applied to body1 and body2 that would correctly resolve the collision between the two bodies. The offsets after each call to \doxylink{collide_8hpp_a6eb18fd72fcf6d0ab2bdad4e42bdf81a}{detect\+Narrow\+Collision()} will have "{}normal \texorpdfstring{$\ast$}{*} depth"{} added to them.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em body1} & The first body to grab the tile data defined by {\ttfamily tile\+Pos1} \\
\hline
\mbox{\texttt{ in}}  & {\em tile\+Pos1} & The tile position of {\ttfamily body1} to check against {\ttfamily tile\+Pos2} \\
\hline
\mbox{\texttt{ in}}  & {\em body1\+Offset} & A world offset to apply to the OBB of the tile defined by {\ttfamily tile\+Pos1} of {\ttfamily body1} \\
\hline
\mbox{\texttt{ in}}  & {\em body2} & The second body to grab the tile data defined by {\ttfamily tile\+Pos2} \\
\hline
\mbox{\texttt{ in}}  & {\em tile\+Pos2} & The tile position of {\ttfamily body2} to check against {\ttfamily tile\+Pos1} \\
\hline
\mbox{\texttt{ in}}  & {\em body2\+Offset} & A world offset to apply to the OBB of the tile defined by {\ttfamily tile\+Pos2} of {\ttfamily body2} \\
\hline
\mbox{\texttt{ out}}  & {\em manifold} & If \doxylink{collide_8hpp_a6eb18fd72fcf6d0ab2bdad4e42bdf81a}{detect\+Narrow\+Collision()} returns true, Will contain a set of contact points and the normal and depth that may be applied to body1 and body2 to resolve the collision of the tiles defined by tile\+Pos1 and tile\+Pos2\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
If true, the collision between the tile of tile\+Pos1 of body1 and the tile of tile\+Pos2 of body2 is occuring. 
\end{DoxyReturn}


Definition at line \mbox{\hyperlink{collide_8hpp_source_l00236}{236}} of file \mbox{\hyperlink{collide_8hpp_source}{collide.\+hpp}}.

\Hypertarget{collide_8hpp_ae2b3dc6f9424aaa03ffca4c47c066863}\label{collide_8hpp_ae2b3dc6f9424aaa03ffca4c47c066863} 
\index{collide.hpp@{collide.hpp}!detectTileBodyCollision@{detectTileBodyCollision}}
\index{detectTileBodyCollision@{detectTileBodyCollision}!collide.hpp@{collide.hpp}}
\doxysubsubsection{\texorpdfstring{detectTileBodyCollision()}{detectTileBodyCollision()}}
{\footnotesize\ttfamily template$<$class Tile\+Data $>$ \\
void detect\+Tile\+Body\+Collision (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{class_tile_body}{Tile\+Body}}$<$ Tile\+Data $>$ \&}]{body1,  }\item[{const \mbox{\hyperlink{class_tile_body}{Tile\+Body}}$<$ Tile\+Data $>$ \&}]{body2,  }\item[{\mbox{\hyperlink{struct_tile_body_collision_cache}{Tile\+Body\+Collision\+Cache}}$<$ Tile\+Data $>$ \&}]{cache,  }\item[{std\+::vector$<$ \mbox{\hyperlink{struct_collision_manifold}{Collision\+Manifold}} $>$ \&}]{manifolds,  }\item[{vec2 \&}]{body1\+Offset,  }\item[{vec2 \&}]{body2\+Offset }\end{DoxyParamCaption})}



Detects the collision between the tiles bodies, body1 and body2. 

Uses chunking as a broad phase to speed up the collision of extremely large tile bodies


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em body1} & The first tile body \\
\hline
\mbox{\texttt{ in}}  & {\em body2} & The second tile body \\
\hline
\mbox{\texttt{ in,out}}  & {\em cache} & In order to speed up collisions, a cache is used to lessen calls to malloc() and free() \\
\hline
\mbox{\texttt{ out}}  & {\em manifolds} & the contact manifolds between the tiles of body1 and body2 \\
\hline
\mbox{\texttt{ out}}  & {\em body1\+Offset} & A world offset to apply to body1 to resolve the collision \\
\hline
\mbox{\texttt{ out}}  & {\em body2\+Offset} & A world offset to apply to body2 to resolve the collision \\
\hline
\end{DoxyParams}


Definition at line \mbox{\hyperlink{collide_8hpp_source_l00299}{299}} of file \mbox{\hyperlink{collide_8hpp_source}{collide.\+hpp}}.

\Hypertarget{collide_8hpp_a8b4c1b30fc6db9efd6a7d53fc7a5d764}\label{collide_8hpp_a8b4c1b30fc6db9efd6a7d53fc7a5d764} 
\index{collide.hpp@{collide.hpp}!findClosestPoint@{findClosestPoint}}
\index{findClosestPoint@{findClosestPoint}!collide.hpp@{collide.hpp}}
\doxysubsubsection{\texorpdfstring{findClosestPoint()}{findClosestPoint()}}
{\footnotesize\ttfamily template$<$typename Container , typename Integer $>$ \\
void find\+Closest\+Point (\begin{DoxyParamCaption}\item[{vec2 \&}]{cp1,  }\item[{vec2 \&}]{cp2,  }\item[{Integer \&}]{count,  }\item[{Float \&}]{distance1,  }\item[{const Container \&}]{points1,  }\item[{const Container \&}]{points2 }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Finds the closest point between points1 and the faces defined by points2. 

The size of vertices1 and vertices2 must be 4. The size of normals must be 2.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in,out}}  & {\em cp1} & The first closest point between points1 and points2 \\
\hline
\mbox{\texttt{ in,out}}  & {\em cp2} & The second closest point between points1 and points2, may not exist \\
\hline
\mbox{\texttt{ in,out}}  & {\em count} & The count of closest points between points1 and points2 \\
\hline
\mbox{\texttt{ in,out}}  & {\em distance1} & Contains the minimum distance between points1 and faces defined by points2 \\
\hline
\mbox{\texttt{ in}}  & {\em points1} & The set of points used to find the closest point in the faces defined by points2 \\
\hline
\mbox{\texttt{ in}}  & {\em points2} & The set of points that define faces that points1 will check against \\
\hline
\end{DoxyParams}


Definition at line \mbox{\hyperlink{collide_8hpp_source_l00139}{139}} of file \mbox{\hyperlink{collide_8hpp_source}{collide.\+hpp}}.

\Hypertarget{collide_8hpp_a6ac4ea60615ca0897b0d8865b4f2c24e}\label{collide_8hpp_a6ac4ea60615ca0897b0d8865b4f2c24e} 
\index{collide.hpp@{collide.hpp}!satBoxTest@{satBoxTest}}
\index{satBoxTest@{satBoxTest}!collide.hpp@{collide.hpp}}
\doxysubsubsection{\texorpdfstring{satBoxTest()}{satBoxTest()}}
{\footnotesize\ttfamily template$<$class Box\+Vertex\+Container , class Normal\+Container $>$ \\
bool sat\+Box\+Test (\begin{DoxyParamCaption}\item[{const Box\+Vertex\+Container \&}]{vertices1,  }\item[{const Box\+Vertex\+Container \&}]{vertices2,  }\item[{const Normal\+Container \&}]{normals,  }\item[{\mbox{\hyperlink{struct_collision_manifold}{Collision\+Manifold}} \&}]{manifold }\end{DoxyParamCaption})}



Returns the normal and depth of two polygons defined by the vertices {\ttfamily vertices1} and {\ttfamily vertices2} by using {\ttfamily normals} inside of the {\ttfamily manifold}. 

The size of vertices1 and vertices2 must be 4. The size of normals must be 2.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em vertices1} & The first set of vertices that define a convex polygon \\
\hline
\mbox{\texttt{ in}}  & {\em vertices2} & The second set of vertices that define a convex polygon \\
\hline
\mbox{\texttt{ out}}  & {\em manifold} & If \doxylink{collide_8hpp_a6ac4ea60615ca0897b0d8865b4f2c24e}{sat\+Box\+Test()} returns true, it will contain the normal and depth of penetration between vertices1 and vertices2 inside of its members, \textquotesingle{}normal\textquotesingle{} and \textquotesingle{}depth\textquotesingle{}\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Will return true if there was a collision detected, false otherwise 
\end{DoxyReturn}


Definition at line \mbox{\hyperlink{collide_8hpp_source_l00089}{89}} of file \mbox{\hyperlink{collide_8hpp_source}{collide.\+hpp}}.



\doxysubsection{Variable Documentation}
\Hypertarget{collide_8hpp_ad9dbe769c3903fe9993db6014bfbfdb4}\label{collide_8hpp_ad9dbe769c3903fe9993db6014bfbfdb4} 
\index{collide.hpp@{collide.hpp}!collideInfos@{collideInfos}}
\index{collideInfos@{collideInfos}!collide.hpp@{collide.hpp}}
\doxysubsubsection{\texorpdfstring{collideInfos}{collideInfos}}
{\footnotesize\ttfamily std\+::vector$<$Collide\+Info$>$ debug\+::collide\+Infos}



Definition at line \mbox{\hyperlink{collide_8hpp_source_l00071}{71}} of file \mbox{\hyperlink{collide_8hpp_source}{collide.\+hpp}}.

